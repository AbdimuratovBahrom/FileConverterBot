import os
import logging
import pypandoc
from aiohttp import web
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

from aiogram import Bot, Dispatcher, types
from aiogram.types import FSInputFile
from aiogram.filters import Command
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from dotenv import load_dotenv


# –õ–æ–∫–∞–ª—å–Ω—ã–µ –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä—ãle

# –¢—è–∂—ë–ª—ã–µ —á–µ—Ä–µ–∑ CloudConvert
# bot.py
from converters.api_utils import cloudconvert_convert
from converters.text import convert_text_file
from converters.audio import convert_audio_file
from converters.video import convert_video_file
from converters.image import convert_image_file
from converters.svg import convert_svg_file
from converters.pdf import convert_pdf_file


BOT_TOKEN = os.getenv("BOT_TOKEN")
WEBHOOK_PATH = "/webhook"
WEBHOOK_URL = f"{os.getenv('RENDER_EXTERNAL_URL')}{WEBHOOK_PATH}"
PORT = int(os.getenv("PORT", 10000))

bot = Bot(
    token=BOT_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()

async def main():
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ–±—Ö—É–∫
    await bot.set_webhook(WEBHOOK_URL)

    app = web.Application()
    webhook_handler = SimpleRequestHandler(dispatcher=dp, bot=bot)
    webhook_handler.register(app, path=WEBHOOK_PATH)
    setup_application(app, dp, bot=bot)

    return app

def convert_docx_to_pdf(input_file, output_file):
    pypandoc.convert_file(
        input_file,
        "pdf",  # —Ñ–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞
        outputfile=output_file,
        extra_args=['--standalone']
    )
    return output_file


async def convert_pdf_file(file_path, target_format="docx"):
    return await cloudconvert_convert(file_path, target_format)

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await message.answer("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä —Ñ–∞–π–ª–æ–≤.\n–ü—Ä–æ—Å—Ç–æ –ø—Ä–∏—à–ª–∏ –º–Ω–µ –¥–æ–∫—É–º–µ–Ω—Ç.")

@dp.message()
async def handle_docs(message: types.Message):
    if not message.document:
        return await message.reply("üìÇ –ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–∞–π–ª –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")

    file_id = message.document.file_id
    file = await bot.get_file(file_id)
    file_path = file.file_path
    file_name = message.document.file_name
    file_ext = file_name.split(".")[-1].lower()

    os.makedirs("downloads", exist_ok=True)
    downloaded_path = f"downloads/{file_name}"
    await bot.download_file(file_path, downloaded_path)

    target_format = "pdf"  # ‚ö° —Ç–µ—Å—Ç–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Å—ë –≤ PDF

    try:
        if file_ext in ["txt", "docx", "rtf", "odt", "epub", "pdf"]:
            output_file = convert_text_file(downloaded_path, target_format)
        elif file_ext in ["jpg", "jpeg", "png", "gif", "webp"]:
            output_file = convert_image_file(downloaded_path, target_format)
        elif file_ext == "svg":
            output_file = convert_svg_file(downloaded_path, target_format)
        elif file_ext in ["mp3", "wav", "ogg"]:
            output_file = convert_audio_file(downloaded_path, target_format)
        elif file_ext in ["mp4", "avi", "mkv"]:
            output_file = convert_video_file(downloaded_path, target_format)
        elif file_ext in ["zip", "rar", "7z"]:
            output_file = convert_archive_file(downloaded_path, target_format)
        elif file_ext in ["ttf", "otf", "woff"]:
            output_file = convert_font_file(downloaded_path, target_format)
        else:
            return await message.reply("‚ùå –≠—Ç–æ—Ç —Ñ–æ—Ä–º–∞—Ç –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.")

        if output_file:
            await message.reply_document(FSInputFile(output_file))
            os.remove(output_file)
        else:
            await message.reply("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏.")

    except Exception as e:
        await message.reply(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")

if __name__ == "__main__":
    web.run_app(main(), host="0.0.0.0", port=PORT)








    import os
import tempfile
import asyncio
from fastapi import FastAPI, Request
from aiogram import Bot, Dispatcher, F, types
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from converters.text import convert_text_file
from converters.image import convert_image_file
from converters.audio import convert_audio_file
from converters.archive import extract_archive, create_archive
from converters.api_utils import cloudconvert_convert

BOT_TOKEN = os.getenv("BOT_TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")  # https://your-app.onrender.com/webhook

bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

app = FastAPI()


# === HANDLERS ===
@dp.message(F.document)
async def handle_file(message: types.Message):
    doc = message.document
    file_name = doc.file_name.lower()

    # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
    file_path = os.path.join(tempfile.gettempdir(), file_name)
    await message.bot.download(doc, destination=file_path)

    ext = os.path.splitext(file_name)[1]

    try:
        # --- –¢–µ–∫—Å—Ç–æ–≤—ã–µ ---
        if ext in [".docx", ".txt", ".md", ".rtf", ".odt", ".html", ".epub"]:
            out_file = convert_text_file(file_path, target_format="txt")
            await message.answer_document(open(out_file, "rb"))

        # --- –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ---
        elif ext in [".png", ".jpg", ".jpeg", ".webp", ".bmp", ".tiff", ".svg"]:
            out_file = convert_image_file(file_path, target_format="png")
            await message.answer_document(open(out_file, "rb"))

        # --- –ê—Ä—Ö–∏–≤—ã ---
        elif ext in [".zip", ".rar", ".7z"]:
            out_dir = extract_archive(file_path)
            new_zip = create_archive(out_dir, "zip")
            await message.answer_document(open(new_zip, "rb"))

        # --- PDF ---
        elif ext == ".pdf":
            out_file = cloudconvert_convert(file_path, "docx")
            await message.answer_document(open(out_file, "rb"))

        # --- –ê—É–¥–∏–æ ---
        elif ext in [".mp3", ".wav", ".ogg", ".flac", ".m4a"]:
            out_file = convert_audio_file(file_path, "wav")
            await message.answer_document(open(out_file, "rb"))

        # --- –í–∏–¥–µ–æ ---
        elif ext in [".mp4", ".avi", ".mkv", ".webm", ".mov", ".wmv"]:
            out_file = cloudconvert_convert(file_path, "mp4")
            await message.answer_document(open(out_file, "rb"))

        else:
            await message.answer("‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç!")

    except Exception as e:
        await message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")


# === WEBHOOK ===
@app.on_event("startup")
async def on_startup():
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º webhook –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
    if WEBHOOK_URL:
        await bot.set_webhook(f"{WEBHOOK_URL}/webhook")


       

    print("üöÄ Bot started via webhook")


@app.on_event("shutdown")
async def on_shutdown():
    await bot.session.close()
    print("üõë Bot stopped")


@app.post("/webhook")
async def webhook(request: Request):
    data = await request.json()
    update = types.Update(**data)
    await dp.feed_update(bot, update)
    return {"ok": True}


# –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –∂–∏–≤–æ–π
@app.get("/")
async def index():
    return {"status": "ok", "message": "Bot is running"}
